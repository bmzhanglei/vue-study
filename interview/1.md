### 1. computed 和 watch 的区别和运用的场景？
computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；

watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

**运用场景：**
* 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
* 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

### 什么是异步组件？
```js
new Vue({
 components: {
 ‘tweet-box’: () => import(‘./components/async/TweetBox’)
 }
}); 
```

### vue性能优化
+ 路由懒加载
+ keep-alive缓存页面
+ 活用v-show，减少v-if 
+ v-for遍历避免同时使用v-if  
+ 长列表性能优化（仅渲染可视化部分）
  + 如果列表是纯粹的数据展示，不会有任何变化，就不需要做优化
  + 如果是大数据列表，可采用虚拟滚动，只渲染少部分区域的内容
  + vue-virtual-scroller、vue-virtual-scroll-list
+ 事件的销毁
+ 图片懒加载 vue-lazyload
+ 第三方插件按需引入
+ 无状态组件标记为函数式组件
+ 子组件拆分  重处理写在子组件中
+ 变量本地化
+ 活用延迟装载
+ 分批处理（Time slicing）
```js
fetchItems({ commit }, { items }) {
    commit('clearItems');
    commit('addItems', items)
}

fetchItems({ commit }, { items, splitCount }) {
    commit('clearItems');
    //新建一个队列
    const queue = new JobQueue();
    splitArray(items, splitCount).forEach(chunk => queue.addJob(done => {
        // 分片
        requestAnimationFrame(() => {
            commit('addItems', chunk);
            done()
        });
    }));
    
    // 等待所有数据处理完毕
    await queue.start();
}
```
+ 非响应模式（non-reactive）
```js
const data = items.map(item => optimizeItem(item));

function optimizeItem (item) {
    const itemData = {
        id: uid ++,
        vote: 0
    };
    Object.defineProperty(itemData, 'data', {
        // mark as non-reactive
        configurable: false,
        value: item
    });
    return itemData
}
```

1. 简单的单页应用可以忽略优化细节，重点可放在功能是现实上
2. 对于拥有上百个对象协作，交互渲染的应用时，应该对于每个细节部分考虑使用优化技巧
3. 影响页面渲染效率的操作，例如低于60fps的时候，为防止影响用户的操作体验，必须考虑优化细节
4. 对于拥有大量计算或者渲染耗时操作，应该随时记测处理的时间，积极思考优化策略，哪怕只能提高1的效率都是值得的


### 什么是虚拟dom
浏览器渲染引擎工作流程5步，创建DOM树——创建StyleRules——创建Render树——布局Layout——绘制Painting
* 第一步，用HTML分析器，分析HTML元素，构建一颗DOM树(标记化和树构建)。
* 第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。
* 第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名renderer)。这些render对象最终会被构建成一颗Render树。
* 第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。
* 第五步，Render树和节点显示坐标都有了，就调用每个节点paint方法，把它们绘制出来

### 为什么要用虚拟dom呢？来看下js用dom操作的代价
用我们传统的开发模式，原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。例如，第一次计算完，紧接着下一个DOM更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算DOM节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验。

### 那么为什么用虚拟dom
Web界面由DOM树(树的意思是数据结构)来构建，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化，
虚拟DOM就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。所以，用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制

### 理解vue中的diff算法
1. diff算法是虚拟DOM技术的必然产物:通过新旧虚拟DOM作对比(即diff)，将变化的地方更新在真 实DOM上;另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)。
2. vue 2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，只有引入diff才能精确找到 发生变化的地方。
3. vue中diff执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果oldVnode和新的渲染结果newVnode，此过程称为patch。
4. diff过程整体遵循深度优先、同层比较的策略;两个节点之间比较会根据它们是否拥有子节点或者文 本节点做不同操作;比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果 没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点;借助key通常可以非 常精确找到相同节点，因此整个patch过程非常高效。


### w万条接口数据下 如何优化vue 接值 及赋值
有2个方式修改数组是不会被vue监听到的
1. 通过数组索引修改内容的时候
2. 通过改变数组长度的方法

利用以上2点 我们可以在不被vue监听的情况下  接受后台的 1w条数据 然后 不渲染页面 仅仅当作储存使用

```js
data(){
    return {
      list1:[], //声明数组list1
    }
  }

freezeList1(){  
  // l 为模拟的1w条数据
  const l = [{name:'a'},{name:'b'},{name:'c'},{name:'d'},{name:'e'},{name:'f'}]
 
  this.list1.length = l.length  // 修改数组长度 为for循环准备  这里vue是不会被监听的
 
  for(let i =0;i<l.length;i++){
     this.list1[i]=l[i] // 索引赋值 这里vue也是不会监听的
  }
  console.info(this.list1)
}

```
通过上面的代码 我们可以看到 list1 在页面渲染出来的 是个空数组 当我们执行 freezeList1方法后
list1 已经变成了1w条数据 但是我们的页面渲染的还是空数组
然后我们可以利用窗口可视化 或者页面滚动等方法 分批次的 从list1里取出值  赋值给 list2
这里给list2赋值 用 直接赋值 或者 set的方法
 总之是使用可以被vue监听的方式   这样就缓解了1w条数据 同时赋值给vue变量的问题

### 手写 Promise
```js
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'
class MyPromise{
    constructor(executor){
        this.status = PENDING;
        this.value = undefined;
        this.reason = undefined;
        this.fullfilledCallbacks = [];
        this.rejectedCallbacks = [];
        let resolve = (value)=>{
           if(this.status === PENDING){
               this.status = FULFILLED
               this.value = value
               this.fullfilledCallbacks.forEach(fn=>fn())
           }
        }
        let reject = (value)=>{
           if(this.status === PENDING){
               this.status = REJECTED
               this.reason = reason
               this.rejectedCallbacks.forEach(fn=>fn())
           }
        }
        try{
            executor(resolve,reject)
        }catch(e){
            reject(e)
        }
    }
    then(onFulfilled,onRejected){
        if(this.status === FULFILLED){
            onFulfilled(this.value)
        }
        if(this.status === REJECTED){
            onRejected(this.reason)
        }
        if(this.status===PENDING){
            this.fullfilledCallbacks.push(()=>{
                onFulfilled(this.value)
            })
            this.rejectedCallbacks.push(()=>{
                onRejected(this.reason)
            })
        }
    }
}
```

```js
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';
function resolvePromise(x, resolve,reject){
    if(x instanceof MyPromise){
        // promise对象
        x.then(resolve,reject)
    }else{
        // 普通值
        resolve(x)
    }
}
class MyPromise {
    constructor(executor){  // executor 执行器
        // 立即执行
        executor(this.resolve,this.reject)
    }
    // promise 状态
    status = PENDING
    // 成功之后的值
    value= undefined
    // 失败之后的原因
    err= undefined

    // 成功回调
    successCallback= []
    // 失败回调
    failCallback= []

    resolve= value=>{
        // 如果状态不是等待 阻止程序继续执行
        // 将状态改为成功
        if(this.status !== PENDING) return
        this.status= FULFILLED
        // 保存成功的值，then函数要拿到
        this.value= value
        // 判断成功回调是否存在 如果存在  调用
        // this.successCallback && this.successCallback(this.value)
        while(this.successCallback.length) this.successCallback.shift()(this.value)
    }
    reject= reason=>{
        if(this.status !== PENDING) return
        this.status= REJECTED
        // 保存失败原因
        this.err= reason
        // 判断成功回调是否存在 如果存在  调用
        // this.failCallback && this.failCallback(this.value)
        while(this.failCallback.length) this.failCallback.shift()(this.err)
    }

    then(successCallback,failCallback){ //接收两个回调函数 成功 失败
        // 定义一个新的promise对象实现链式调用
        let newPromise= new MyPromise((resolve,reject)=>{
            if(this.status === FULFILLED){
                let x= successCallback(this.value)
                // resolve(x)
                resolvePromise(x,resolve,reject)
            }else if(this.status === REJECTED){
                failCallback(this.err)
            }else{
                // 执行器是异步操作时，status还是pending，
                // 所以此时并不知道是成功还是失败回调，那么这里就需要把这两个回调
                // 存储起来
                this.successCallback.push(successCallback),
                this.failCallback.push(failCallback)
            }
        })
        return newPromise

    }
}

module.exports= MyPromise

//

const MyPromise= require('./MyPromise')
let promise= new MyPromise((resolve,reject)=>{
    // setTimeout(()=>{
    //     resolve("成功...")
    // },5000)
    resolve("成功")
})

function other(){
    return new MyPromise((resolve,reject)=>{
        resolve('other')
    })
}

promise.then(value=>{
    console.log('one: '+ value)
    return other()
}).then(res=>{
    console.log('two: '+ res)
})

```