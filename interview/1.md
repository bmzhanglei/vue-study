
### vue-router有两种传参方式

(1)通过在router.js文件中配置path的地方动态传递参数 eg: path: '/detail/:id' 然后在组件内通过this.$route.params.id即可获取

(2).在router-link标签中传递参数

``` 
<router-link :to={ params: { x: 1 }  } />
```
也通过this.$route.params获取 

注意：这里通过router-link传递参数的方式是隐式传参

### 1. computed 和 watch 的区别和运用的场景？
computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；

watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

**运用场景：**
* 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
* 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

### 2. vue-router 路由模式有几种？
* hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器
* history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式
* abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.

### 3. vue-router 中常用的 hash 和 history 路由模式实现原理
（1）hash 模式的实现原理
早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：` https://www.word.com#search`
hash 路由模式的实现主要是基于下面几个特性：
* URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
* hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
* 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
* 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。

（2）history 模式的实现原理
HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：
```
window.history.pushState(data, title, path);
window.history.replaceState(null, null, path);
```
history 路由模式的实现主要基于存在下面几个特性：
* pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
* 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；
* history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。

### 什么是异步组件？
```js
new Vue({
 components: {
 ‘tweet-box’: () => import(‘./components/async/TweetBox’)
 }
}); 
```

### vue性能优化
+ 路由懒加载
+ keep-alive缓存页面
+ 活用v-show，减少v-if 
+ v-for遍历避免同时使用v-if  
+ 长列表性能优化（仅渲染可视化部分）
  + 如果列表是纯粹的数据展示，不会有任何变化，就不需要做优化
  + 如果是大数据列表，可采用虚拟滚动，只渲染少部分区域的内容
  + vue-virtual-scroller、vue-virtual-scroll-list
+ 事件的销毁
+ 图片懒加载 vue-lazyload
+ 第三方插件按需引入
+ 无状态组件标记为函数式组件
+ 子组件拆分  重处理写在子组件中
+ 变量本地化
+ 活用延迟装载
+ 分批处理（Time slicing）
```js
fetchItems({ commit }, { items }) {
    commit('clearItems');
    commit('addItems', items)
}

fetchItems({ commit }, { items, splitCount }) {
    commit('clearItems');
    //新建一个队列
    const queue = new JobQueue();
    splitArray(items, splitCount).forEach(chunk => queue.addJob(done => {
        // 分片
        requestAnimationFrame(() => {
            commit('addItems', chunk);
            done()
        });
    }));
    
    // 等待所有数据处理完毕
    awiat queue.start();
}
```
+ 非响应模式（non-reactive）
```js
const data = items.map(item => optimizeItem(item));

function optimizeItem (item) {
    const itemData = {
        id: uid ++,
        vote: 0
    };
    Object.defineProperty(itemData, 'data', {
        // mark as non-reactive
        configurable: false,
        value: item
    });
    return itemData
}
```

1. 简单的单页应用可以忽略优化细节，重点可放在功能是现实上
2. 对于拥有上百个对象协作，交互渲染的应用时，应该对于每个细节部分考虑使用优化技巧
3. 影响页面渲染效率的操作，例如低于60fps的时候，为防止影响用户的操作体验，必须考虑优化细节
4. 对于拥有大量计算或者渲染耗时操作，应该随时记测处理的时间，积极思考优化策略，哪怕只能提高1的效率都是值得的


### 什么是虚拟dom
浏览器渲染引擎工作流程5步，创建DOM树——创建StyleRules——创建Render树——布局Layout——绘制Painting
* 第一步，用HTML分析器，分析HTML元素，构建一颗DOM树(标记化和树构建)。
* 第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。
* 第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名renderer)。这些render对象最终会被构建成一颗Render树。
* 第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。
* 第五步，Render树和节点显示坐标都有了，就调用每个节点paint方法，把它们绘制出来

### 为什么要用虚拟dom呢？来看下js用dom操作的代价
用我们传统的开发模式，原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。例如，第一次计算完，紧接着下一个DOM更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算DOM节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验。

### 那么为什么用虚拟dom
Web界面由DOM树(树的意思是数据结构)来构建，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化，
虚拟DOM就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。所以，用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制

### 理解vue中的diff算法
1. diff算法是虚拟DOM技术的必然产物:通过新旧虚拟DOM作对比(即diff)，将变化的地方更新在真 实DOM上;另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)。
2. vue 2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，只有引入diff才能精确找到 发生变化的地方。
3. vue中diff执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果oldVnode和新的渲染结果newVnode，此过程称为patch。
4. diff过程整体遵循深度优先、同层比较的策略;两个节点之间比较会根据它们是否拥有子节点或者文 本节点做不同操作;比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果 没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点;借助key通常可以非 常精确找到相同节点，因此整个patch过程非常高效。


### w万条接口数据下 如何优化vue 接值 及赋值
有2个方式修改数组是不会被vue监听到的
1. 通过数组索引修改内容的时候
2. 通过改变数组长度的方法

利用以上2点 我们可以在不被vue监听的情况下  接受后台的 1w条数据 然后 不渲染页面 仅仅当作储存使用

```js
data(){
    return {
      list1:[], //声明数组list1
    }
  }

freezeList1(){  
  // l 为模拟的1w条数据
  const l = [{name:'a'},{name:'b'},{name:'c'},{name:'d'},{name:'e'},{name:'f'}]
 
  this.list1.length = l.length  // 修改数组长度 为for循环准备  这里vue是不会被监听的
 
  for(let i =0;i<l.length;i++){
     this.list1[i]=l[i] // 索引赋值 这里vue也是不会监听的
  }
  console.info(this.list1)
}

```
通过上面的代码 我们可以看到 list1 在页面渲染出来的 是个空数组 当我们执行 freezeList1方法后
list1 已经变成了1w条数据 但是我们的页面渲染的还是空数组
然后我们可以利用窗口可视化 或者页面滚动等方法 分批次的 从list1里取出值  赋值给 list2
这里给list2赋值 用 直接赋值 或者 set的方法
 总之是使用可以被vue监听的方式   这样就缓解了1w条数据 同时赋值给vue变量的问题

 ### HTTP1和HTTP2的区别
1. Http1.x
缺陷：线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被阻塞。

2. Http1.0(短连接)
缺陷：浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接（TCP连接的新建成本很高，因为需要客户端和服务器三次握手），服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；
解决方案：添加头信息——非标准的Connection字段Connection: keep-alive

3. Http1.1
改进点：

持久连接（与Http1其它版本的最大区别）
引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive(对于同一个域名，大多数浏览器允许同时建立6个持久连接)
管道机制
分块传输编码
即服务端每产生一块数据，就发送一块，采用”流模式”而取代”缓存模式”。
新增请求方式
PUT:请求服务器存储一个资源;
DELETE：请求服务器删除标识的资源；
OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求；
TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断；
CONNECT：保留将来使用
缺点：
虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。这将导致“队头堵塞”
避免方式：一是减少请求数，二是同时多开持久连接

4. Http/2.0

特点：
采用二进制格式而非文本格式；
完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行；（解决了线头阻塞的问题，与Http1最重要的区别）
使用报头压缩，降低开销
服务器推送

4.1 二进制协议
HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。
二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。

4.2 完全多路复用
HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。
4.3 报头压缩
HTTP 协议是没有状态，导致每次请求都必须附上所有信息。所以，请求的很多头字段都是重复的，比如Cookie，一样的内容每次请求都必须附带，这会浪费很多带宽，也影响速度。
对于相同的头部，不必再通过请求发送，只需发送一次；
HTTP/2 对这一点做了优化，引入了头信息压缩机制；
一方面，头信息使用gzip或compress压缩后再发送；
另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。
4.4 服务器推送
HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS.

### 手写 Promise
```js
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'
class Promise{
    constructor(executor){
        this.status = PENDING;
        this.value = undefined;
        this.reason = undefined;
        let resolve = (value)=>{
           if(this.status === PENDING){
               this.status = FULFILLED
               this.value = value
           }
        }
        let reject = (value)=>{
           if(this.status === PENDING){
               this.status = REJECTED
               this.reason = reason
           }
        }
        try{
            executor(resolve,reject)
        }catch(e){
            reject(e)
        }
    }
    then(onFulfilled,onRejected){
        if(this.status === FULFILLED){
            onFulfilled(this.value)
        }
        if(this.status === REJECTED){
            onRejected(this.reason)
        }
    }
}
```