
### token的作用

* 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：
1. 客户端使用用户名跟密码请求登录。
2. 通过ajax向后端发送请求。
3. 服务端收到请求，去验证用户名与密码。
4. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
5. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里
6. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Toke（不管是你自己写的）它都要通过ajax向后端发送请求，这时服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据

### 什么是TCP、UDP以及两者的区别

* TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，是专门为了在不可靠的网络中提供一个可靠的端对端字节流而设计的，面向字节流。
* UDP（用户数据报协议）是iso参考模型中一种无连接的传输层协议，提供简单不可靠的非连接传输层服务，面向报文
区别：
1. TCP是面向连接的，可靠性高；UDP是基于非连接的，可靠性低
2. 由于TCP是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差，同时过程复杂，也使其易于攻击；UDP没有建立连接的过程，因而实时性较强，也稍安全
3. 在传输相同大小的数据时，TCP首部开销20字节；UDP首部开销8字节，TCP报头比UDP复杂，故实际包含的用户数据较少。TCP在IP协议的基础上添加了序号机制、确认机制、超时重传机制等，保证了传输的可靠性，不会出现丢包或乱序，而UDP有丢包，故TCP开销大，UDP开销较小
4. 每条TCP连接只能时点到点的；UDP支持一对一、一对多、多对一、多对多的交互通信


### HTTP1和HTTP2的区别
1. Http1.x
缺陷：线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被阻塞。

2. Http1.0(短连接)
缺陷：浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接（TCP连接的新建成本很高，因为需要客户端和服务器三次握手），服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；
解决方案：添加头信息——非标准的Connection字段Connection: keep-alive

3. Http1.1
改进点：
持久连接（与Http1其它版本的最大区别）
引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive(对于同一个域名，大多数浏览器允许同时建立6个持久连接)
管道机制
分块传输编码
即服务端每产生一块数据，就发送一块，采用”流模式”而取代”缓存模式”。
新增请求方式
PUT:请求服务器存储一个资源;
DELETE：请求服务器删除标识的资源；
OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求；
TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断；
CONNECT：保留将来使用

缺点：
虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。这将导致“队头堵塞”
避免方式：一是减少请求数，二是同时多开持久连接

4. Http/2.0
特点：
采用二进制格式而非文本格式；
完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行；（解决了线头阻塞的问题，与Http1最重要的区别）
使用报头压缩，降低开销
服务器推送

4.1 二进制协议
HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。
二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。

4.2 完全多路复用
HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。

4.3 报头压缩
HTTP 协议是没有状态，导致每次请求都必须附上所有信息。所以，请求的很多头字段都是重复的，比如Cookie，一样的内容每次请求都必须附带，这会浪费很多带宽，也影响速度。
对于相同的头部，不必再通过请求发送，只需发送一次；
HTTP/2 对这一点做了优化，引入了头信息压缩机制；
一方面，头信息使用gzip或compress压缩后再发送；
另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。

4.4 服务器推送
HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS.

5. 对http3.0的理解
  * http3把下层的TCP协议改成UDP，所以不会出现HTTP1.1的队头阻塞和HTTP2的丢包全部重传问题。
  * 是基于UDP的QUIC协议（本质上是UDP的低延时的互联网传输层协议），实现了TCP的可靠性，TLS的安全性和HTTP2的并发性。
    用一个等式描述 QUIC = UDP + TLS + HTTP

  队头阻塞
    分为TCP队头阻塞和HTTP队头阻塞
  TCP队头阻塞：发生在一个TCP分节丢失，导致其后续分节不按序到达接收端。
  HTTP队头阻塞：HTTP管道化引起的请求队头阻塞，只要其中一个响应延时就会造成队头阻塞

  如何解决TCP队头阻塞？
  无法避免，跟本身机制有关，只有舍弃TCP协议，改用QUIC协议和SCTP（流控制传输协议）

  如何解决HTTP队头阻塞
  http1.1中解决的方法是域名分片和并发连接。
  HTTP2不使用管道化的方式，而是引入了帧、消息和数据流等概念，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了请求/响应阻塞。


## 网络安全
### CSRF：跨站请求伪造
   1. csrf 能成功的原因在于：借助浏览器 cookie 的机制，非法使用了用户的 cookie。
   2. 攻击者无法读取和操作 cookie，只是发起伪造请求，带上了 cookie。

   * 可能造成危害：
     利用已通过认证的用户权限更新设定信息等；
     利用已通过认证的用户权限购买商品；
     利用已通过的用户权限在留言板上发表言论。

   防范策略
   1. 禁用跨域请求
   2. 携带一些本域下才会生成的字段（需要对 token 的合法性进行一次计算验证）

### XSS：跨站脚本攻击
  * 代码被恶意注入到页面中（例如评论），然后其他用户在访问页面时，浏览器执行了代码逻辑。
    1. 利用虚假输入表单骗取用户个人信息。
    2. 利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。
  * 防御策略
    1. httpOnly: 在 cookie 中设置 HttpOnly 属性，使js脚本无法读取到 cookie 信息。
    2. 浏览器自带 X-XSS-Protection
    3. 特殊字符转义
    4. 标签过滤（仅对安全 html 标签进行渲染，其他不与渲染）
    5. 内容安全策略（CSP）